import pytest

import numpy as np
import warnings
from functools import partial

from powerbox.powerbox import PowerBox
from powerbox.tools import (
    _getbins,
    _magnitude_grid,
    above_mu_min_angular_generator,
    angular_average,
    angular_average_nd,
    get_power,
    regular_angular_generator,
)

get_power = partial(get_power, bins_upto_boxlen=True)
angular_average = partial(angular_average, bins_upto_boxlen=True)
angular_average_nd = partial(angular_average_nd, bins_upto_boxlen=True)


def test_warn_interp_weights():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0
    P = np.repeat(P, 100).reshape(400, 400, 100)
    freq = [x, x, np.linspace(-2, 2, 100)]
    weights = np.random.rand(np.prod(P.shape)).reshape(P.shape)
    with pytest.warns(RuntimeWarning):
        angular_average(
            P,
            freq,
            bins=10,
            interpolation_method="linear",
            weights=weights,
            interp_points_generator=regular_angular_generator(),
        )
    with pytest.warns(RuntimeWarning):
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                message="'nan-aware' interpolation uses two",
                category=UserWarning,
            )
            angular_average(
                P,
                freq,
                bins=10,
                interpolation_method="nan-aware",
                weights=weights,
                bin_ave=False,
                interp_points_generator=regular_angular_generator(),
            )


def test_bins_upto_boxlen_warning():
    with pytest.warns(
        FutureWarning,
        match="In the future, bins will be generated by default up to the smallest",
    ):
        _getbins(bins=10, coord_mags=np.ones((10, 10)), log=False)


@pytest.mark.parametrize("xmax", [1, 10, np.pi])
@pytest.mark.parametrize("ndim", [1, 2, 3])
def test_bins_upto_boxlen(xmax, ndim):
    x = np.linspace(-xmax, xmax, 21)
    mag = _magnitude_grid([x] * ndim)

    bins = _getbins(bins=12, coord_mags=mag, log=False, bins_upto_boxlen=True)
    assert bins.max() == xmax


@pytest.mark.parametrize("xmax", [1, 10, np.pi])
@pytest.mark.parametrize("ndim", [1, 2, 3])
def test_bins_upto_maxmag(xmax, ndim):
    x = np.linspace(-xmax, xmax, 21)
    mag = _magnitude_grid([x] * ndim)

    bins = _getbins(bins=12, coord_mags=mag, log=False, bins_upto_boxlen=False)
    assert np.isclose(bins.max(), xmax * np.sqrt(ndim))


@pytest.mark.parametrize("interpolation_method", [None, "linear", "nan-aware"])
def test_angular_avg_nd_3(interpolation_method):
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0
    P = np.repeat(P, 100).reshape(400, 400, 100)
    freq = [x, x, np.linspace(-2, 2, 100)]
    with warnings.catch_warnings():
        warnings.filterwarnings(
            "ignore",
            message="'nan-aware' interpolation uses two",
            category=UserWarning,
        )
        p_k, k_av_bins, *_ = angular_average_nd(
            field=P,
            coords=freq[:2],
            bins=50,
            interpolation_method=interpolation_method,
            bins_upto_boxlen=True,
        )
    # k avg bins is always the same in each layer
    k_av_bins = k_av_bins[:, 0]
    if interpolation_method is not None:
        assert np.max(np.abs((p_k[:, 0] - k_av_bins**-2.0) / k_av_bins**-2.0)) < 0.05
    else:
        # Without interpolation, the radially-averaged power is not very accurate
        # due to the low number of bins at small values of k_av_bins, so we start
        # the comparison at the 6th bin.
        assert (
            np.max(np.abs((p_k[6:, 0] - k_av_bins[6:] ** -2.0) / k_av_bins[6:] ** -2.0))
            < 0.05
        )


def test_weights_shape():
    x = np.linspace(-3, 3, 40)
    P = np.ones(3 * [40])
    weights = np.ones(3 * [20])
    freq = [x for _ in range(3)]

    with pytest.raises(ValueError):
        p_k_lin, k_av_bins_lin = angular_average(
            P, freq, bins=10, weights=weights, bins_upto_boxlen=True
        )


@pytest.mark.parametrize("n", range(1, 5))
def test_interp_w_weights(n):
    x = np.linspace(-3, 3, 20)
    P = np.ones(n * [20])
    weights = np.ones_like(P)
    if n == 1:
        P[2:5] = 0
        weights[2:5] = 0
    elif n == 2:
        P[2:5, 2:5] = 0
        weights[2:5, 2:5] = 0
    elif n == 3:
        P[:4, 3:6, 7:10] = 0
        weights[:4, :, :] = 0
        weights[:, 3:6, :] = 0
        weights[:, :, 7:10] = 0
    else:
        P[:4, 3:6, 7:10, 1:2] = 0
        weights[:4, :, :, :] = 0
        weights[:, 3:6, :, :] = 0
        weights[:, :, 7:10, :] = 0
        weights[:, :, :, 1:2] = 0

    # Test 4D avg works
    freq = [x for _ in range(n)]
    p_k_lin, *_ = angular_average(
        field=P,
        coords=freq,
        bins=10,
        interpolation_method="linear",
        weights=weights,
        interp_points_generator=regular_angular_generator(angular_resolution=0.4),
        log_bins=True,
        bins_upto_boxlen=True,
    )

    assert np.all(p_k_lin == 1.0)

    # Test 4D avg works (nan-aware)
    freq = [x for _ in range(n)]
    with warnings.catch_warnings():
        warnings.filterwarnings(
            "ignore",
            message="'nan-aware' interpolation uses two",
            category=UserWarning,
        )
        p_k_lin, *_ = angular_average(
            field=P,
            coords=freq,
            bins=10,
            interpolation_method="nan-aware",
            weights=weights,
            interp_points_generator=regular_angular_generator(angular_resolution=0.4),
            log_bins=True,
            bins_upto_boxlen=True,
        )

    assert np.all(p_k_lin == 1.0)


@pytest.mark.parametrize("n", range(1, 3))
def test_zero_ki(n):
    x = np.arange(-100, 100, 1)
    from powerbox.tools import ignore_zero_ki

    # needed only for shape
    freq = n * [x]
    coords = np.array(np.meshgrid(*freq))
    kmag = np.sqrt(np.sum(coords**2, axis=0))
    weights = ignore_zero_ki(freq, kmag)
    L = x[-1] - x[0] + 1
    masked_points = np.sum(weights == 0)
    if n == 1:
        assert masked_points == 1
    elif n == 2:
        assert masked_points == n * L - 1
    elif n == 3:
        assert masked_points == n * L**2 - n * L + 1
    else:
        assert masked_points == n * L**3 - n * L**2 + n * L - 1


@pytest.mark.parametrize("n", range(2, 3))
def test_interp_w_mu(n):
    x = np.linspace(0.0, 3, 40)
    if n == 2:
        kpar_mesh, kperp_mesh = np.meshgrid(x, x)
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore", message="divide by zero encountered in divide"
            )
            theta = np.arctan2(kperp_mesh, kpar_mesh)
        mu_mesh = np.cos(theta)
    else:
        kx_mesh, ky_mesh, kz_mesh = np.meshgrid(x, x, x, indexing="ij")
        theta = np.arccos(kz_mesh / np.sqrt(kx_mesh**2 + ky_mesh**2 + kz_mesh**2))
        mu_mesh = np.cos(theta)

    # Need a little cushion so we test against data at mu = 0.95
    # If we test for mu that is higher (default is mu >= 0.97)
    # and put the data also only at mu >= 0.97, then the interped average will
    # not be 1. at low radii so the test fails.
    mask = mu_mesh >= 0.95
    P = np.zeros(mask.shape)
    P[mask] = 1.0

    p_k_lin, *_ = angular_average(
        P,
        n * [x],
        bins=10,
        interpolation_method="linear",
        weights=1.0,
        interp_points_generator=above_mu_min_angular_generator(),
        bins_upto_boxlen=True,
    )
    # Start from the 4th bin due to the average being a bit < 1 at low radii
    assert np.all(p_k_lin[3:] == 1.0)


def test_error_coords_and_mask():
    x = np.linspace(1.0, 3, 40)
    kpar_mesh, kperp_mesh = np.meshgrid(x, x)
    theta = np.arctan2(kperp_mesh, kpar_mesh)
    mu_mesh = np.cos(theta)

    mask = mu_mesh >= 0.97
    P = np.zeros(mask.shape)
    P[mask] = 1.0
    with pytest.raises(ValueError):
        p_k_lin, k_av_bins_lin = angular_average(
            P,
            [x, x],
            bins=10,
            interpolation_method="linear",
            weights=1.0,
            interp_points_generator=above_mu_min_angular_generator(mu=0.97),
            bins_upto_boxlen=True,
        )


def test_interp_method():
    x = np.linspace(-3, 3, 40)
    P = np.ones((40, 40, 40))
    freq = [x, x, x]
    with pytest.raises(ValueError):
        angular_average_nd(
            field=P,
            coords=freq,
            bins=20,
            get_variance=True,
            interpolation_method="abc",
            bins_upto_boxlen=True,
        )

    with pytest.raises(ValueError):
        angular_average_nd(
            field=P,
            coords=freq,
            bins=20,
            get_variance=True,
            interpolation_method=True,
            bins_upto_boxlen=True,
        )

    with pytest.raises(ValueError):
        angular_average(
            field=P,
            coords=freq,
            bins=20,
            get_variance=True,
            interpolation_method="abc",
            bins_upto_boxlen=True,
        )


def test_error_w_kmag_coords():
    x = np.linspace(-3, 3, 40)
    P = np.ones((40, 40, 40))
    X, Y = np.meshgrid(x, x)

    with pytest.raises(ValueError):
        angular_average_nd(
            field=P, coords=X**2 + Y**2, bins=20, interpolation_method="linear"
        )

    x = np.linspace(-3, 3, 40)
    P = np.ones((40, 40, 40))
    X, Y = np.meshgrid(x, x)

    with pytest.raises(ValueError):
        angular_average(
            field=P, coords=X**2 + Y**2, bins=20, interpolation_method="linear"
        )


@pytest.mark.parametrize("n", range(1, 3))
def test_angular_avg_nd(n):
    x = np.linspace(-3, 3, 40)
    X, Y, Z = np.meshgrid(x, x, x)
    r2 = X**2 + Y**2 + Z**2
    P = r2**-1.0

    # Test 4D avg works
    P = np.repeat(P, 10).reshape(40, 40, 40, 10)
    freq = [x, x, x, np.linspace(-2, 2, 10)]

    p_k_lin, k_av_bins_lin, *_ = angular_average_nd(
        field=P,
        coords=freq[:n],
        bins=10,
        interpolation_method="linear",
        bins_upto_boxlen=True,
    )
    k_av_bins_lin = k_av_bins_lin.reshape((k_av_bins_lin.shape[0], -1))[:, 0]

    if n == 1:
        # Without interpolation, the radially-averaged power is not very accurate
        # due to the low number of bins at small values of k_av_bins, so we start
        # the comparison at the 6th bin.
        assert (
            np.max(
                np.abs(
                    (
                        p_k_lin[6:, len(x) // 2, len(x) // 2, 0]
                        - k_av_bins_lin[6:] ** -2.0
                    )
                    / k_av_bins_lin[6:] ** -2.0
                )
            )
            < 0.05
        )
    elif n == 2:
        assert (
            np.max(
                np.abs(
                    (p_k_lin[:, len(x) // 2, 0] - k_av_bins_lin**-2.0)
                    / k_av_bins_lin**-2.0
                )
            )
            < 0.05
        )
    else:
        assert (
            np.max(np.abs((p_k_lin[:, 0] - k_av_bins_lin**-2.0) / k_av_bins_lin**-2.0))
            < 0.05
        )


def test_angular_avg_nd_complex_interp():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0 + 1j * r2**-1.0
    P = np.repeat(P, 100).reshape(400, 400, 100)
    freq = [x, x, np.linspace(-2, 2, 100)]
    p_k_lin, k_av_bins_lin, *_ = angular_average_nd(
        field=P,
        coords=freq[:2],
        bins=50,
        interpolation_method="linear",
        bins_upto_boxlen=True,
    )
    real = np.real(p_k_lin)
    imag = np.imag(p_k_lin)
    k_av_bins_lin = k_av_bins_lin[:, 0]
    assert (
        np.max(np.abs((real[:, 0] - k_av_bins_lin**-2.0) / k_av_bins_lin**-2.0)) < 0.05
    )

    np.testing.assert_allclose(real, imag)


@pytest.mark.parametrize("interpolation_method", [None, "linear"])
def test_angular_avg_nd_4_2(interpolation_method):
    x = np.linspace(-3, 3, 200)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0
    P = np.repeat(P, 10).reshape(200, 200, 10)
    P = np.repeat(P, 10).reshape(200, 200, 10, 10)

    freq = [x, x, np.linspace(-2, 2, 10), np.linspace(-2, 2, 10)]
    angular_average_nd(field=P, coords=freq[:2], bins=50)
    p_k_lin, k_av_bins_lin, *_ = angular_average_nd(
        field=P,
        coords=freq[:2],
        bins=50,
        interpolation_method=interpolation_method,
        bins_upto_boxlen=True,
    )
    # The radially-averaged power is not very accurate
    # due to the low number of bins at small values of k_av_bins, so we start
    # the comparison at the 6th bin.
    assert (
        np.max(
            np.abs(
                (p_k_lin[6:, 0, 0] - k_av_bins_lin[6:, 0, 0] ** -2.0)
                / k_av_bins_lin[6:, 0, 0] ** -2.0
            )
        )
        < 0.06
    )


def test_var_not_impl():
    x = np.linspace(-3, 3, 200)
    P = np.ones((200, 10))
    coords = [x, np.linspace(-2, 2, 10)]
    _, _, vv, _ = angular_average(
        P, coords, bins=20, get_variance=True, interpolation_method="linear"
    )
    assert vv is None


def test_angular_avg_nd_2_1_varnull():
    x = np.linspace(-3, 3, 200)

    P = np.ones((200, 10))

    coords = [x, np.linspace(-2, 2, 10)]
    vv = angular_average_nd(
        field=P,
        coords=coords[:1],
        bins=20,
        get_variance=True,
        bins_upto_boxlen=True,
    )[2]

    assert np.all(vv == 0)


def test_null_variance_2d():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = np.ones_like(r2)
    vv = angular_average(
        P,
        np.sqrt(r2),
        bins=np.linspace(0, x.max(), 20),
        get_variance=True,
        bins_upto_boxlen=True,
    )[2]
    np.testing.assert_allclose(vv, 0)


def test_variance_2d():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = np.ones_like(r2)
    P += np.random.normal(scale=1, size=(len(x), len(x)))
    _, _, vv, _ = angular_average(
        P,
        np.sqrt(r2),
        bins=np.linspace(0, x.max(), 20),
        get_variance=True,
        bins_upto_boxlen=True,
    )
    assert np.all(np.diff(vv) <= 0)


def test_complex_variance():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = np.ones_like(r2) + np.ones_like(r2) * 1j
    with pytest.raises(NotImplementedError):
        angular_average(
            P,
            np.sqrt(r2),
            bins=np.linspace(0, x.max(), 20),
            get_variance=True,
            bins_upto_boxlen=True,
        )


def test_bin_edges():
    x = np.linspace(-3, 3, 200)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0
    bins = np.linspace(0, x.max(), 20)
    _, coord, *_ = angular_average(
        P, np.sqrt(r2), bins=bins, bin_ave=False, bins_upto_boxlen=True
    )
    np.testing.assert_allclose(coord, bins)


def test_sum():
    x = np.linspace(-3, 3, 200)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0
    ave, *_ = angular_average(
        P, np.sqrt(r2), bins=20, bin_ave=False, average=False, bins_upto_boxlen=True
    )
    assert np.sum(P[r2 < 9.0]) == np.sum(ave)

    ave, *_ = angular_average(
        P, np.sqrt(r2), bins=20, bin_ave=True, average=False, bins_upto_boxlen=True
    )
    assert np.sum(P[r2 < 9.0]) == np.sum(ave)


def test_var_trivial_weights():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = np.ones_like(r2)
    P += np.random.normal(scale=1, size=(len(x), len(x)))
    var = angular_average(
        P,
        np.sqrt(r2),
        bins=np.linspace(0, x.max(), 20),
        get_variance=True,
        weights=np.ones_like(r2),
        bins_upto_boxlen=True,
    )[2]
    print(np.diff(var))
    assert np.all(np.diff(var) <= 1e-6)


def test_logbins():
    x = np.linspace(-3, 3, 400)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = np.ones_like(r2)
    _, coord, *_ = angular_average(
        P, np.sqrt(r2), bins=10, bin_ave=False, log_bins=True, bins_upto_boxlen=True
    )

    np.testing.assert_allclose(np.diff(coord[1:] / coord[:-1]), 0, atol=3e-15)


def test_cross_power_identity():
    pb = PowerBox(200, dim=2, pk=lambda k: 1.0 * k**-2.0, boxlength=1.0, b=1)
    dx = pb.delta_x()
    p, *_ = get_power(dx, pb.boxlength, b=1)
    p_cross, *_ = get_power(dx, pb.boxlength, b=1, deltax2=dx)
    np.testing.assert_allclose(p, p_cross)
    p, *_ = get_power(dx, [1, 1], b=1)
    p_cross, *_ = get_power(dx, [1, 1], b=1, deltax2=dx)
    np.testing.assert_allclose(p, p_cross)


@pytest.mark.skip()
def test_against_multirealisation():
    x = np.linspace(-3, 3, 1000)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    bins = np.linspace(0, x.max(), 20)

    # Get the variance from several realisations
    ave = [0] * 50
    for j in range(50):
        P = np.ones_like(r2) + np.random.normal(scale=1, size=(len(x), len(x)))
        ave[j], *_ = angular_average(P, np.sqrt(r2), bins=bins)

    var = np.var(np.array(ave), axis=0)

    # Get the variance from a single realisation
    ave, _, var2, _ = angular_average(P, np.sqrt(r2), bins=bins, get_variance=True)

    print(var)
    print(var2)
    np.testing.assert_allclose(var, var2, 1e-2)


def test_angular_average_shape_exceptions():
    """Test passing incorrect coordinate shapes to angular_average"""
    x = np.linspace(-3, 3, 20)
    X, Y = np.meshgrid(x, x)
    r2 = X**2 + Y**2
    P = r2**-1.0

    with pytest.raises(
        ValueError, match=r"list of coords must be same length as field.ndim"
    ):
        angular_average(field=P, coords=[x], bins=4)

    with pytest.raises(
        ValueError,
        match="coords must be a list of 1D coordinate arrays when interpolating",
    ):
        angular_average(field=P, coords=r2, bins=20, interpolation_method="linear")

    with pytest.raises(
        ValueError, match="coords must have the same shape as the field"
    ):
        angular_average(field=P, coords=x, bins=4)


def test_angular_averaged_nd_shape_exceptions():
    """Test passing incorrect coordinate shapes to angular_average_nd"""
    x = np.linspace(-3, 3, 20)
    X, Y, Z = np.meshgrid(x, x, x)
    r2 = X**2 + Y**2 + Z**2
    P = r2**-1.0

    with pytest.raises(ValueError, match="coords given imply ndim_to_avg of 0"):
        angular_average_nd(field=P, coords=[], bins=4)

    with pytest.raises(ValueError, match="coords given imply ndim_to_avg of 4"):
        angular_average_nd(field=P, coords=[x] * 4, bins=4)

    with pytest.raises(ValueError, match="weights must have shape"):
        angular_average_nd(field=P, coords=r2, weights=P[1:], bins=4)


@pytest.mark.parametrize("interpolation_method", ["linear", "nan-aware"])
class TestInterpSimilarToNoInterp:
    """Check that interpolated angular averages are close to non-interpolated ones."""

    def test_angular_average_2d(self, interpolation_method):
        """2D field averaged to 1D with angular_average."""
        x = np.linspace(-3, 3, 200)
        X, Y = np.meshgrid(x, x)
        r2 = X**2 + Y**2
        P = r2**-1.0
        bins = np.linspace(0, x.max(), 30)

        avg_none, k_none, _, sw_none = angular_average(
            P, [x, x], bins=bins, interpolation_method=None
        )
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                message="'nan-aware' interpolation uses two",
                category=UserWarning,
            )
            avg_interp, k_interp, _, sw_interp = angular_average(
                P, [x, x], bins=bins, interpolation_method=interpolation_method
            )

        # Skip first few bins where cell counts are very low
        start = 3
        valid = np.isfinite(avg_none[start:]) & np.isfinite(avg_interp[start:])
        rel_err = np.abs(
            (avg_interp[start:][valid] - avg_none[start:][valid])
            / avg_none[start:][valid]
        )
        assert np.max(rel_err) < 0.10, (
            f"Max relative error {np.max(rel_err):.4f} exceeds 10% "
            f"for {interpolation_method}"
        )

    def test_angular_average_3d(self, interpolation_method):
        """3D field averaged to 1D with angular_average."""
        x = np.linspace(-3, 3, 60)
        X, Y, Z = np.meshgrid(x, x, x, indexing="ij")
        r2 = X**2 + Y**2 + Z**2
        P = r2**-1.0
        bins = np.linspace(0, x.max(), 20)

        avg_none, k_none, _, sw_none = angular_average(
            P, [x, x, x], bins=bins, interpolation_method=None
        )
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                message="'nan-aware' interpolation uses two",
                category=UserWarning,
            )
            avg_interp, k_interp, _, sw_interp = angular_average(
                P, [x, x, x], bins=bins, interpolation_method=interpolation_method
            )

        start = 3
        valid = np.isfinite(avg_none[start:]) & np.isfinite(avg_interp[start:])
        rel_err = np.abs(
            (avg_interp[start:][valid] - avg_none[start:][valid])
            / avg_none[start:][valid]
        )
        assert np.max(rel_err) < 0.10, (
            f"Max relative error {np.max(rel_err):.4f} exceeds 10% "
            f"for {interpolation_method}"
        )

    def test_angular_average_nd_2d_field(self, interpolation_method):
        """3D field with angular_average_nd averaging over 2 dims."""
        x = np.linspace(-3, 3, 200)
        X, Y = np.meshgrid(x, x)
        r2 = X**2 + Y**2
        P = r2**-1.0
        # Add an extra dimension so angular_average_nd averages 2D â†’ 1D+extra
        P = np.repeat(P, 10).reshape(200, 200, 10)
        freq = [x, x, np.linspace(-2, 2, 10)]

        avg_none, k_none, *_ = angular_average_nd(
            field=P, coords=freq[:2], bins=30, interpolation_method=None
        )
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore",
                message="'nan-aware' interpolation uses two",
                category=UserWarning,
            )
            avg_interp, k_interp, *_ = angular_average_nd(
                field=P,
                coords=freq[:2],
                bins=30,
                interpolation_method=interpolation_method,
            )

        # Compare at a representative slice (middle of extra dim)
        mid = avg_none.shape[1] // 2
        start = 5
        a_none = avg_none[start:, mid]
        a_interp = avg_interp[start:, mid]
        valid = np.isfinite(a_none) & np.isfinite(a_interp) & (a_none != 0)
        rel_err = np.abs((a_interp[valid] - a_none[valid]) / a_none[valid])
        assert np.max(rel_err) < 0.10, (
            f"Max relative error {np.max(rel_err):.4f} exceeds 10% "
            f"for angular_average_nd with {interpolation_method}"
        )


def test_get_power_2d_sumweights_is_1d():
    """When res_ndim < dim, sumweights should be collapsed to 1D."""
    pb = PowerBox(64, dim=3, pk=lambda k: k**-2.0, boxlength=1.0, b=1)
    dx = pb.delta_x()

    p, k, var, sumweights, extra_freq = get_power(dx, pb.boxlength, b=1, res_ndim=2)

    # p has shape (n_bins, n_remaining) but sumweights should be 1D
    assert sumweights.ndim == 1, (
        f"Expected sumweights to be 1D, got shape {sumweights.shape}"
    )
    assert k.ndim == 1, f"Expected k to be 1D, got shape {k.shape}"
    assert sumweights.shape[0] == p.shape[0]
